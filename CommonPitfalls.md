# Общие проблемы при разработке приложений для операционнай системы Sailfish

## Отсутствие полезных активных обложек

Обложки активных приложений (активные обложки), собранные на одном экране, являются основой многозадачности операционной системы Sailfish. Однако при адаптации приложений под операционну систему Sailfish концепция активных обложек может показаться разработчикам незначительной, потому что такие системы, как Android, iOS и оригинальные приложения N9 Meego не имеют подобной функциональности.С помощью активных обложек можно не только легко переключаться между приложениями, но и просматривать состояния экранов или совершать основные действия в открытых приложениях, не посещая их. Активная обложка должна предоставлять пользователю основную информацию о приложении, показывать рабочие задачи и обеспечивать быстрый доступ к основным действиям, например, сохранению нового элемента или поиску элементов в списке, когда приложение свернуто на домашний экран.



## Non-standard label coloring/ Нестандартные цвета !этикеток!

Стиль платформы ОС Sailfish цвета используются, чтобы указывать на интерактивность компонента. Существуют исключения, но в большинстве случаев кнопки, переключтели, эелемнты списка и другие !пункты!(items), которые должны реагиовать на прикосновения (действия) пользователя, окрашены в основные цвета темы. Объекты, которые используются для статические надписи, описания интерфейса или заголовки окрашены в фоновые цвета(подсветка) выбранной атмосферы. 

Например, для элемента в примере ниже используется тема Theme.highlightColor, потому что он неинтерактивный. 


//Нестандартная окраска элементов экрана  
В стиле платформы Sailfish OS используются цвета, указывающие, является ли элемент пользовательского интерфейса интерактивным. Есть некоторые исключения, но обычно кнопки, переключатели, элементы списка и другие элементы, которые реагируют на сенсорный ввод, окрашены в основной цвет, а чисто описательные элементы, такие как статические метки, заголовки страниц и разделов, окрашены цветом подсветки атмосферы.
Например, ярлык ниже окрашен в Theme.highlightColor, поскольку он не является интерактивным:
//

```
 Dialog {
    Label {
color: Theme.highlightColor
text: "Terms of Use. By selecting Accept you agree to..." width: parent.width
    }
}
```
Элементы интерфейса и иконки должны быть окрашены при нажатии в цвета подсветки. 
На левой картинке показан первый пункт в списке, окрашенный в в осовыне цвета, хотя пункт уже выбран. Это не соответствует стилю платформы Sailfish. На правой картинке выбранный пункт подсвежичается, как и ожидается. 

![]()

Компоненты Silica со встроенным текстом, такие как Button, ComboBox и ContextMenu, автоматически окрашивают текст при нажатии. Однако для пользовательских компонентов автоматическую подсветку текста необходимо будет реализовать этот эффект самостоятельно. Например:

```
 ListItem {
     id: listItem
     width: parent.width
Label {
text: model.text
color: listItem.highlighted ? Theme.highlightColor :
Theme.primaryColor
     }
}
```
Смотри Документацию по [теме]() для рекомендаций по эффектам стилизации.
See the Theme documentation for guidelines on styling press effects.
         
## Неправильное выравнивание, размеры или интервал

Элементы приложения пользовательского интерфейса и их содержимое должны располагаться хорошо на дисплее, и их размер должен соответствовать стандарту ОС Sailfish. Использование согласованного выравнивания, размер и интервал важны для визуальной привлекательности и удобочитаемости. (Необходимо использовтаь консистентные правила для выравнивания, размеров и межстрочных интервалов для элеиентов интерфейса. Это улучшит визуальное восприятие интерфейса и повысит чатемость.
)


В приложениях Sailfish графика и изображения обычно выравниваются по краям страницы (например, изображение отображается в галерее или в альбомной графике в Media). Текстовое содержимое и значки в элементах управления пользовательским интерфейсом обычно отделяются от краев страницы с пометкой Theme.horizontalPageMargin на левом и правом краях экрана и Theme.paddingLarge сверху и снизу.

Некоторые текстовые контролы, например, комбобоксы, текстовые поля, заголовки страницы уже используют для задания горизонтальных границ отступы для содержимого из Theme.horizontalPageMargin. Эти отступы могут быть изменены с помощью значений в свойствах leftMargin и rightMargin (например, (PageHeader leftMargin)[#]). Чтобы создать собственные пользовательские эхеленты, необходимо добавить эти отступы. Например, элемент, описанный ниже в примере, привязывается к полной ширине родительского элемента, а затем устанавливает свойства anchors.leftMargin и anchors.rightMargin, если это необходимо:

```
Page { Label {
      
text: "A very, very, very long sentence that will extend beyond the width of the screen."
         truncationMode: TruncationMode.Fade
         color: Theme.highlightColor
anchors {
left: parent.left
leftMargin: Theme.horizontalPageMargin right: parent.right
rightMargin: Theme.horizontalPageMargin verticalCenter: parent.verticalCenter
} }
}
```

Элементы пользовательского интерфейса, такие как размер шрифта и список входных элементов должен и


Элементы пользовательского интерфейса, такие как размеры шрифтов и входные элементы списка, также должны быть правильного рпзмера и консистентны в соответствии со стандартным стилем ОС Sailfish. Это можно легко сделать с помощью объекта Тема, который предоставляет набор стандартных размеров, отступов и цветов для стилизации содержимого пользовательского интерфейса Sailfish. Подробная информация и руковоство приведены в документации к Theme.

## Сенсорные области слишком малы
Разработчики приложений иногда имеют тенденцию создавать приложения с элементами пользовательского интерфейса, которые очень малы. Это проблема, если элементы интерактивны, поскольку небольшие области касания требуют большего когнитивного усилия, чтобы успешно нажать. Кроме того, большинство компонентов интерфейса Sailfish не имеют визуальных границ для интерактивной области, поэтому легко ошибиться в размерах сенсорных областей.

Чтобы максимизировать (увеличить до предела) области касания элементов, увеличьте размер свойства MouseArea. Если элемент размещен с помощью типа позиционирования Row или Column перемещайте инетрвалы (количество в пикселях, оставшихся пустыми между соседними элементами) между элеменетами внутрь области касания элемента. Сенсорные элементы не должны быть меньше высоты, указанной в свойствах Theme.itemSizeSmall. На самом деле, большинство сенсорных элементов должны быть высотой Theme.itemSizeMedium или больше, в зависимости от их сложности.

        
## Слишком много элементов в меню Pulley
 
Меню Pulley должно иметь минимальное количество опций. Вы бы не стали втискивать 6-8 элементов в традиционную панель инструментов мобильнго приложения, то же самое относится к меню Pulley в Sailfish ОС. Большинство приложений платформы Sailfish предоставляют только 1-3 возможных действия в меню Pulley на странице. Чтобы обеспечить легкий доступ к меню и незагроможденный опыт, никогда не показывайте более четырех действий в PullDownMenu или PushUpMenu.


## Отображение неактивных меню Pulley
   
Некоторые параметры меню Pulley становятся доступными только при выполнении определенных условий. Если меню Pulley все элементы меню неактивны, то само меню Pulley не должно показываться(быть спрятано), чтобы не показывать пункты меню, которые нельзя использовтаь.

```
 PullDownMenu {
     MenuItem { text: "Remove" }
     visible: playList.selectionCount > 0
 }
```

## Отсутствует значок прокрутки

Любое представление (экран, ), которое может накапливать контент, который может выходить за пределы экрана, должен иметь значок прокрутки. Он указывает положение текущего окна просмотра в "представлении" и подсказывают количество доступного содержимого вне экрана.

```
SilicaListView {
    anchors.fill: parent
    VerticalScrollDecorator {}
}
```
 
## Использование кнопок вместо жестов в стиле платформы
В Sailfish жесты «принять» и «отменить» заменяют традиционные кнопки accept и cancel для подтверждения или отмены. Жест назад back-stepping заменяет традиционные кнопку "назад", а жест скремблирования(Для этого потянуть от левого или правого края экрана к центру, а затем, не отрывая, провести обратно к краю.) к дому делает ненужными кнопки «выход» и «домой». Кроме того, меню Pulley заменяет традиционные панели инструментов в приложениях.
Управление устройством основано на жестах.

Эти жесты должны использоваться везде, где это возможно, чтобы обеспечить пользовательский интерфейс, совместимый с приложениями платформы. Например, на правом изображении выше в диалоговом окне используются кнопки «Принять» и «Отмена», предоставляемые DialogHeader, вместо использования отдельных кнопок «Принять» и «Отмена». Действия кнопки могут быть реализованы с помощью обработчиков сигналов в Диалоге onAccepted и onRejected:

```
Dialog {
    onAccepted: account.logIn()
    onRejected: accountCreationCanceled()
}
```    

## Недостаточная маркировка текстового редактора / Insufficient text editor labeling

Каждый текстовый редактор Sailfish должен определять значения для свойств placeholderText и label. Текст заполнителя(подсказка к заголовку) отображается, когда поле ввода пустое; он описывает, что пользователь должен ввести в поле. Метка (название, имя поля) имеет ту же цель, но отображается после того, как пользователь уже ввел текст в поле. Оба свойства могут использовать одну и ту же строку для описания, такую как «Имя», «Фамилия», «Электронная почта» и т. Д.

```
Column {
     width: parent.width
     TextField {
         placeholderText: "First name"
         label: "First name"
         width: parent.width
} TextArea {
} }
placeholderText: "Last name"
label: "Last name"
width: parent.width
```

## Отсутствует конфигурация/настройка для клавиши Enter

Так как кнопка Enter не может создать дополнительную строку в текстовом поле с одной строкой, функциональность этой клавиши может быть перенастроена с помощью свойства EnterKey для выполнения настраиваемого действия. Обычно клавиша Enter используется для перемещения фокуса клавиатуры между последовательными текстовыми полями:

```
TextField {
     label: "Username"
     placeholderText: "Username"
     width: parent.width
// Only allow Enter key to be pressed when text has been entered EnterKey.enabled: text.length > 0
// Show 'next' icon to indicate pressing Enter will move the // keyboard focus to the next text field in the page EnterKey.iconSource: "image://theme/icon-m-enter-next"
// When Enter key is pressed, move the keyboard focus to the // next field
EnterKey.onClicked: passwordField.focus = true
}
```
Если поле 

Если поле является последним на странице, клавиша Enter также может использоваться для сохранения или отправки введенных данных.

```
 TextField {
     label: "Password"
     placeholderText: "Password"
     width: parent.width
 
EnterKey.enabled: text.length > 0
EnterKey.iconSource: "image://theme/icon-m-enter-accept" EnterKey.onClicked: account.login()
}
```

Если такие действия не применимы, клавиша Enter может быть перегружена, чтобы закрыть экранную клавиатуру при нажатии.

```
 TextField {
     label: "Password"
     placeholderText: "Password"
     width: parent.width
EnterKey.iconSource: "image://theme/icon-m-enter-close"
     EnterKey.onClicked: focus = false
 }
```

## Громоздкая иерархия страниц
Хотя [стек страницы]() приложения позволяет пользователям легко перемещаться между различными экранами в вашем приложении, если стек страниц имеет глубокую иерархию, пользователь может запутаться в том, где находится текущий экран в приложении. Вместо того, чтобы постоянно добавлять всё больше страниц на стек, рассмотрите возможность замены страниц с помощью метода [replace()](). Например, поиск приложений в приложении Maps заменяет существующие поисковые страницы, а не добавляет новые, чтобы избежать громоздкой (и в теории бесконечно растущей) иерархии стека страниц.
